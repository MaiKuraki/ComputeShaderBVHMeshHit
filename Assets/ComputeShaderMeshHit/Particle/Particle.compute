#pragma kernel Update NUM_THREAD_X=1024

#include "Particle.hlsl"
#include "Bvh.hlsl"


RWStructuredBuffer<Particle> particleBuffer;
float3 spawnBoundsMin;
float3 spawnBoundsMax;
float gravity;
float bounceRate;
float time; // for random
float deltaTime;

inline float random(float2 xy)
{
    return frac(sin(dot(xy ,float2(12.9898,78.233))) * 43758.5453);
}

float3 Respawn(uint id)
{
    float3 rand3 = float3(
        random(float2(id   * 0.01, time)),
        random(float2(id+1 * 0.01, time)),
        random(float2(id+2 * 0.01, time))
    );

    return lerp(spawnBoundsMin, spawnBoundsMax, rand3);
}

[numthreads(NUM_THREAD_X,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    uint num, stride;
    particleBuffer.GetDimensions(num, stride);
    if (num <= id.x) return;

    Particle particle = particleBuffer[id.x];
    float3 pos = particle.position;
    float3 velocity = particle.velocity;

    // Calc velocity
    velocity.y += -gravity * deltaTime;

    float3 step = velocity * deltaTime;

    // Check hit
#if 0
    float rayScale;
    float3 normal;
    if ( TraverseTriangles(particle.position, step, rayScale, normal) )
    {
        if ( rayScale <= 1.0)
        {
            velocity = reflect(velocity, normal) * bounceRate;
        }
    }
#endif


#if 1
    float rayScale;
    float3 normal;
    if ( TraverseBvh(pos, step, rayScale, normal) )
    {
        if ( rayScale <= 1.0)
        {
            velocity = reflect(velocity, normal) * bounceRate;
        }
    }
#endif

    // Respawn
    pos += step;
    if ( pos.y < -10){
        pos = Respawn(id.x);
        velocity = (0).xxx;
    }

    particle.position = pos;
    particle.velocity = velocity;

    particleBuffer[id.x] = particle;
}